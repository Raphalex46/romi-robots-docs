{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"In this document you will find information on how to use and build the ROMI robots","title":"Home"},{"location":"Cable/","text":"Wirebot Link Main Board and Eletronics Link Raspberry Pi - packages, Dependencies and Configurations Link Download the image Robotics Ubuntu+ROS Raspberry Pi Image (3B+ Support) that comes with Ubuntu 16.04 (LXDE), and ROS Kinetic. Copy the image to the SD card. Instructions here. Resizes the file system to fill the SD card before booting following this instructions. Acces to the raspi-config utility: $computer :~ $sudo raspi-config Choose \"Expand root partition to fill SD card\" option: The Ubiquityrobotics images come up as a Wifi acces point. The SSID is ubiquityrobotXXXX where XXXX is part of the MAC address. Connect to the wifi hostopost and use folowing wifi password: robotseverywhere Once connected, it is possible to log into the Pi with ssh ubuntu@10.42.0.1 with the following password of: ubuntu Desable the default robots and node runing on the pi. $ ubuntu@ubiquityrobot.local: $sudo systemctl disable magni-base Raspberry Pi - Setting up the WIREDBOT to the Network Link Open a new terminal window, and log in to the robot with ssh: ATENTION : The HOSTNAME for firts time is \u201cubiquityrobot.local\u201d. $ computer:~ $ssh ubuntu@ubiquityrobot.local ATENTION : The password for firts time is \u201cubuntu\u201d. Change the hostname using pifi. Type the following command: $ ubuntu@ubiquityrobot.local:~ $sudo pifi set-hostname wiredbot Reboot the Pi. $ ubuntu@ubiquityrobot.local:~ $sudo reboot Log in to the robot with the new hostname \"wiredbot\": $ computer:~ $ssh ubuntu@wiredbot.local Use pifi to list the nearby networks: $ ubuntu@wiredbot:~ $pifi list seen ATENTION : Search for the network where the robots are connected. Swich to to the desire network by using the following command. $ ubuntu@NEWHOSTNAME:~ $sudo pifi add localNetwork password ATTENTION : The keyword \"localNetwork\" on this documentation refert to the network the robot need to be connected. The keyword \"pass\" on this documentation refer to the password of the network. Reboot the Pi. $ ubuntu@wiredbot:~ $sudo reboot Test the connectivity with the Pi. Open a new terminal window on a external on a diferent computer: $ computer:~ $ping wirebot.local TIP : Press control-c to stop the pinging ADVERTENCE : If something goes wrong, the PI will come back up as access point mode. Search on the network for the name ubiquityrobot, reboot and start over. Log into the PI by using: $ computer:~ $ssh ubuntu@wirebot.local the output will be: The authenticity of host \u201810.0.0.113 ( 10 .0.0.113 ) \u2019 can\u2019t be established. ECDSA key fingerprint is SHA256:sDDeGZzL8FPY3kMmvhwjPC9wH+mGsAxJL/dNXpoYnsc. Are you sure you want to continue connecting ( yes/no ) ? continue by wrinting: $ computer:~ $yes the password is still. ubuntu Update and updagrade de Pi. $ ubuntu@wiredbot:~ $sudo apt-get update $ ubuntu@wiredbot:~ $sudo apt-get upgrade ROS - Setting up the ROS NODES and Arduino Firmware. Link Make sure you have installed the resent updates and updagrades. $ ubuntu@wiredbot:~ $sudo apt-get update $ ubuntu@wiredbot:~ $sudo apt-get upgrade Point to the workspace folder for ros packages Clone the repository on the Pi, the romi/grlbl_serial into the /src folder of your catkin workspace and rebuild your workspace: $ ubuntu@wiredbot:~ $cd ~/catkin_ws/src/ $ ubuntu@wiredbot:~ $git clone git@github.com:romi/grlbl_serial.git $ ubuntu@wiredbot:~ $catkin_make Clone the repository on the Pi, the romi/i2c_pca9685_driver into the /src folder of your catkin workspace and rebuild your workspace: $ ubuntu@wiredbot:~ $cd ~/catkin_ws/src/ $ ubuntu@wiredbot:~ $git clone git@github.com:romi/i2c_pca9685_driver.git $ ubuntu@wiredbot:~ $catkin_make Wiring diagram. Link Schematics: List Part Item Description Quantity 0 Raspberry pi model 3b+ 1 1 Raspberry Pi Camera Module v2 1 2 16-Channel 12-bit - I2C interface - PCA9685 1 3 Arduino UNO 1 4 Arduino CNC Shield V3 1 5 A4988 Stepper Motor Driver 4 6 Nema 23 Unipolar 1.8deg 1 7 Survey3W Camera - Orange+Cyan+NIR (OCN, NDVI) 1 8 Survey3W HDMI PWM Trigger Cable 1 9 Survey3 Advanced GPS Receiver 1 10 12V Power Supply 1 11 Wires and general hardware - Hardware Setup. Link 1.Drawings * Assebly drawing - Top view * Assebly drawing - Botton View List Part Item Description Quantity 0 Aluminium Profile 20\u00d720 T-Slot 5 4 1 Idler Pulley Plate 6 2 Join Plat T 4 3 Corner connector 90 degree (V-Slot) 2 4 Gantry Plate V-Slot 20-80 2 5 3M Drop in Tee Nuts \u2013 Insert nuts 50 6 3M Allen Low Profile Screws 50 7 M8 Allen Screw - 45mm Long 6 8 Motor Mount Plate NEMA 23 1 9 Nylon Pulley And Wheel - 40 mm Diameter - 8 mm Bearing 6 10 Nema 23 stepper motor 1 11 P65 Weatherproof Enclosure/electrical enclosure box 2 12 5mm Shock Cord - Marine Grade Polyester Coated Rubber Rope - Running ROS node - Path Planning Link ROS Nodes Overview. ROS Master - Run ROS Nodes over the raspberry PI. Log into the raspberry PI by using: $ computer:~ $ssh ubuntu@wirebot.local (OPTIONAL) Edit the path planning according to the dimensions of the field to scan and the desired length and amount of waypoints. $ ubuntu@ubiquityrobot.local:~ $sudo nano ~/catkin_ws/src/grlbl_serial/src/path_planning_action_client.py * Edit the path_planning_action_client.py by changing the variable movement_goal.xyz_position that is under the function def path_planning_client() . Here is an example of a Path planning that takes pictures of every 500mm in a distance of 10mts: movement_goal . xyz_position = [ { x :0, y :0, z :500, delay :20} , { x :0, y :0, z :1000, delay :20} , { x :0, y :0, z :1500, delay :20} , { x :0, y :0, z :2000, delay :20} , { x :0, y :0, z :2500, delay :20} , { x :0, y :0, z :3000, delay :20} , { x :0, y :0, z :3500, delay :20} , { x :0, y :0, z :4000, delay :20} , { x :0, y :0, z :4500, delay :20} , { x :0, y :0, z :5000, delay :20} , { x :0, y :0, z :5500, delay :20} , { x :0, y :0, z :6000, delay :20} , { x :0, y :0, z :6500, delay :20} , { x :0, y :0, z :7000, delay :20} , { x :0, y :0, z :7500, delay :20} , { x :0, y :0, z :8000, delay :20} , { x :0, y :0, z :8500, delay :20} , { x :0, y :0, z :9000, delay :20} , { x :0, y :0, z :9500, delay :20} ] Start up the nodes and the ROS master by launching the path_planning_action_server_node node under the raspberry PI: $ ubuntu@ubiquityrobot.local:~ $roslaunch grlbl_serial path_planning_action_server_node.launch (ADVERTENCE) If the ROS package is not under the autocomplete method of the terminal. The problem will be solve by sourcing the devel/setup.bash. $ ubuntu@ubiquityrobot.local:~ $source ~/catkin_ws/src/devel/setup.bash 3. ROS Slave - Run ROS Nodes over the Remote Computer. Start up the nodes by launching the path_planning_action_client_node node under the remote computer: $ ubuntu@ubiquityrobot.local:~ $roslaunch grlbl_serial path_planning_action_client_node.launch (OPTIONAL) This node as well can by launch over the raspberry PI. This can be done by lauching the node over a new terminal. By launching the previous ROS node on the WIREDBOT. The starting process of collecting photos from the Mapir camera and the Raspi Cam will be launch automatically according to the path planning instructions save on the path_planning_action_client.py file. Saving the data from the WIREDBOT. (UNDER-DEVELOPMENT) Link Kepp running or re start the node and the ROS master by launching the path_planning_action_server_node node under the raspberry PI: $ ubuntu@ubiquityrobot.local:~ $roslaunch grlbl_serial path_planning_action_server_node.launch Publish a 1500us to the /i2c_pca9685_driver wiredbot_PWMValues/wiredbot_PWMValues mapir_control_pwm: $ ubuntu@ubiquityrobot.local:~ $rostopic pub -1 /i2c_pca9685_driver wiredbot_PWMValues/wiredbot_PWMValues int16 mapir_control_pwm 1500 int16 motor_A_pwm int16 motor_B_pwm Once ros is publishing the message mapir_control_pwm 1500us under the topic \\i2c_pca9685_driver\\wiredbot_PWMValues. The camera is ready to mount. On the raspberry PI. Mount the camera by using the following commands. $ ubuntu@ubiquityrobot.local:~ $mkdir /mapir $ ubuntu@ubiquityrobot.local:~ $mkdir sudo mount -t vfat /dev/sdb2 /mapir $ ubuntu@ubiquityrobot.local:~ $cd /mapir/DCMI/Photos * Image Gallery - Valldaura: Link Lettuce Think and Wirebot: Wirebot on the field: Wirebot on the field: WIREBOT 3D Scans: Link","title":"Index"},{"location":"Cable/#wirebot","text":"","title":"Wirebot"},{"location":"Cable/#main-board-and-eletronics","text":"","title":"Main Board and Eletronics"},{"location":"Cable/#raspberry-pi-packages-dependencies-and-configurations","text":"Download the image Robotics Ubuntu+ROS Raspberry Pi Image (3B+ Support) that comes with Ubuntu 16.04 (LXDE), and ROS Kinetic. Copy the image to the SD card. Instructions here. Resizes the file system to fill the SD card before booting following this instructions. Acces to the raspi-config utility: $computer :~ $sudo raspi-config Choose \"Expand root partition to fill SD card\" option: The Ubiquityrobotics images come up as a Wifi acces point. The SSID is ubiquityrobotXXXX where XXXX is part of the MAC address. Connect to the wifi hostopost and use folowing wifi password: robotseverywhere Once connected, it is possible to log into the Pi with ssh ubuntu@10.42.0.1 with the following password of: ubuntu Desable the default robots and node runing on the pi. $ ubuntu@ubiquityrobot.local: $sudo systemctl disable magni-base","title":"Raspberry Pi - packages, Dependencies and Configurations"},{"location":"Cable/#raspberry-pi-setting-up-the-wiredbot-to-the-network","text":"Open a new terminal window, and log in to the robot with ssh: ATENTION : The HOSTNAME for firts time is \u201cubiquityrobot.local\u201d. $ computer:~ $ssh ubuntu@ubiquityrobot.local ATENTION : The password for firts time is \u201cubuntu\u201d. Change the hostname using pifi. Type the following command: $ ubuntu@ubiquityrobot.local:~ $sudo pifi set-hostname wiredbot Reboot the Pi. $ ubuntu@ubiquityrobot.local:~ $sudo reboot Log in to the robot with the new hostname \"wiredbot\": $ computer:~ $ssh ubuntu@wiredbot.local Use pifi to list the nearby networks: $ ubuntu@wiredbot:~ $pifi list seen ATENTION : Search for the network where the robots are connected. Swich to to the desire network by using the following command. $ ubuntu@NEWHOSTNAME:~ $sudo pifi add localNetwork password ATTENTION : The keyword \"localNetwork\" on this documentation refert to the network the robot need to be connected. The keyword \"pass\" on this documentation refer to the password of the network. Reboot the Pi. $ ubuntu@wiredbot:~ $sudo reboot Test the connectivity with the Pi. Open a new terminal window on a external on a diferent computer: $ computer:~ $ping wirebot.local TIP : Press control-c to stop the pinging ADVERTENCE : If something goes wrong, the PI will come back up as access point mode. Search on the network for the name ubiquityrobot, reboot and start over. Log into the PI by using: $ computer:~ $ssh ubuntu@wirebot.local the output will be: The authenticity of host \u201810.0.0.113 ( 10 .0.0.113 ) \u2019 can\u2019t be established. ECDSA key fingerprint is SHA256:sDDeGZzL8FPY3kMmvhwjPC9wH+mGsAxJL/dNXpoYnsc. Are you sure you want to continue connecting ( yes/no ) ? continue by wrinting: $ computer:~ $yes the password is still. ubuntu Update and updagrade de Pi. $ ubuntu@wiredbot:~ $sudo apt-get update $ ubuntu@wiredbot:~ $sudo apt-get upgrade","title":"Raspberry Pi - Setting up the WIREDBOT to the Network"},{"location":"Cable/#ros-setting-up-the-ros-nodes-and-arduino-firmware","text":"Make sure you have installed the resent updates and updagrades. $ ubuntu@wiredbot:~ $sudo apt-get update $ ubuntu@wiredbot:~ $sudo apt-get upgrade Point to the workspace folder for ros packages Clone the repository on the Pi, the romi/grlbl_serial into the /src folder of your catkin workspace and rebuild your workspace: $ ubuntu@wiredbot:~ $cd ~/catkin_ws/src/ $ ubuntu@wiredbot:~ $git clone git@github.com:romi/grlbl_serial.git $ ubuntu@wiredbot:~ $catkin_make Clone the repository on the Pi, the romi/i2c_pca9685_driver into the /src folder of your catkin workspace and rebuild your workspace: $ ubuntu@wiredbot:~ $cd ~/catkin_ws/src/ $ ubuntu@wiredbot:~ $git clone git@github.com:romi/i2c_pca9685_driver.git $ ubuntu@wiredbot:~ $catkin_make","title":"ROS - Setting up the ROS NODES and Arduino Firmware."},{"location":"Cable/#wiring-diagram","text":"Schematics: List Part Item Description Quantity 0 Raspberry pi model 3b+ 1 1 Raspberry Pi Camera Module v2 1 2 16-Channel 12-bit - I2C interface - PCA9685 1 3 Arduino UNO 1 4 Arduino CNC Shield V3 1 5 A4988 Stepper Motor Driver 4 6 Nema 23 Unipolar 1.8deg 1 7 Survey3W Camera - Orange+Cyan+NIR (OCN, NDVI) 1 8 Survey3W HDMI PWM Trigger Cable 1 9 Survey3 Advanced GPS Receiver 1 10 12V Power Supply 1 11 Wires and general hardware -","title":"Wiring diagram."},{"location":"Cable/#hardware-setup","text":"1.Drawings * Assebly drawing - Top view * Assebly drawing - Botton View List Part Item Description Quantity 0 Aluminium Profile 20\u00d720 T-Slot 5 4 1 Idler Pulley Plate 6 2 Join Plat T 4 3 Corner connector 90 degree (V-Slot) 2 4 Gantry Plate V-Slot 20-80 2 5 3M Drop in Tee Nuts \u2013 Insert nuts 50 6 3M Allen Low Profile Screws 50 7 M8 Allen Screw - 45mm Long 6 8 Motor Mount Plate NEMA 23 1 9 Nylon Pulley And Wheel - 40 mm Diameter - 8 mm Bearing 6 10 Nema 23 stepper motor 1 11 P65 Weatherproof Enclosure/electrical enclosure box 2 12 5mm Shock Cord - Marine Grade Polyester Coated Rubber Rope -","title":"Hardware Setup."},{"location":"Cable/#running-ros-node-path-planning","text":"ROS Nodes Overview. ROS Master - Run ROS Nodes over the raspberry PI. Log into the raspberry PI by using: $ computer:~ $ssh ubuntu@wirebot.local (OPTIONAL) Edit the path planning according to the dimensions of the field to scan and the desired length and amount of waypoints. $ ubuntu@ubiquityrobot.local:~ $sudo nano ~/catkin_ws/src/grlbl_serial/src/path_planning_action_client.py * Edit the path_planning_action_client.py by changing the variable movement_goal.xyz_position that is under the function def path_planning_client() . Here is an example of a Path planning that takes pictures of every 500mm in a distance of 10mts: movement_goal . xyz_position = [ { x :0, y :0, z :500, delay :20} , { x :0, y :0, z :1000, delay :20} , { x :0, y :0, z :1500, delay :20} , { x :0, y :0, z :2000, delay :20} , { x :0, y :0, z :2500, delay :20} , { x :0, y :0, z :3000, delay :20} , { x :0, y :0, z :3500, delay :20} , { x :0, y :0, z :4000, delay :20} , { x :0, y :0, z :4500, delay :20} , { x :0, y :0, z :5000, delay :20} , { x :0, y :0, z :5500, delay :20} , { x :0, y :0, z :6000, delay :20} , { x :0, y :0, z :6500, delay :20} , { x :0, y :0, z :7000, delay :20} , { x :0, y :0, z :7500, delay :20} , { x :0, y :0, z :8000, delay :20} , { x :0, y :0, z :8500, delay :20} , { x :0, y :0, z :9000, delay :20} , { x :0, y :0, z :9500, delay :20} ] Start up the nodes and the ROS master by launching the path_planning_action_server_node node under the raspberry PI: $ ubuntu@ubiquityrobot.local:~ $roslaunch grlbl_serial path_planning_action_server_node.launch (ADVERTENCE) If the ROS package is not under the autocomplete method of the terminal. The problem will be solve by sourcing the devel/setup.bash. $ ubuntu@ubiquityrobot.local:~ $source ~/catkin_ws/src/devel/setup.bash 3. ROS Slave - Run ROS Nodes over the Remote Computer. Start up the nodes by launching the path_planning_action_client_node node under the remote computer: $ ubuntu@ubiquityrobot.local:~ $roslaunch grlbl_serial path_planning_action_client_node.launch (OPTIONAL) This node as well can by launch over the raspberry PI. This can be done by lauching the node over a new terminal. By launching the previous ROS node on the WIREDBOT. The starting process of collecting photos from the Mapir camera and the Raspi Cam will be launch automatically according to the path planning instructions save on the path_planning_action_client.py file.","title":"Running ROS node - Path Planning"},{"location":"Cable/#saving-the-data-from-the-wiredbot-under-development","text":"Kepp running or re start the node and the ROS master by launching the path_planning_action_server_node node under the raspberry PI: $ ubuntu@ubiquityrobot.local:~ $roslaunch grlbl_serial path_planning_action_server_node.launch Publish a 1500us to the /i2c_pca9685_driver wiredbot_PWMValues/wiredbot_PWMValues mapir_control_pwm: $ ubuntu@ubiquityrobot.local:~ $rostopic pub -1 /i2c_pca9685_driver wiredbot_PWMValues/wiredbot_PWMValues int16 mapir_control_pwm 1500 int16 motor_A_pwm int16 motor_B_pwm Once ros is publishing the message mapir_control_pwm 1500us under the topic \\i2c_pca9685_driver\\wiredbot_PWMValues. The camera is ready to mount. On the raspberry PI. Mount the camera by using the following commands. $ ubuntu@ubiquityrobot.local:~ $mkdir /mapir $ ubuntu@ubiquityrobot.local:~ $mkdir sudo mount -t vfat /dev/sdb2 /mapir $ ubuntu@ubiquityrobot.local:~ $cd /mapir/DCMI/Photos *","title":"Saving the data from the WIREDBOT. (UNDER-DEVELOPMENT)"},{"location":"Cable/#image-gallery-valldaura","text":"Lettuce Think and Wirebot: Wirebot on the field: Wirebot on the field:","title":"Image Gallery - Valldaura:"},{"location":"Cable/#wirebot-3d-scans","text":"","title":"WIREBOT 3D Scans:"},{"location":"Rover/","text":"In this document you will find information on how to use and build the ROMI Rover... User Manual Hardware Documentation Software Installation Developer Documentation","title":"Index"},{"location":"Rover/developer/","text":"Dev","title":"Developer Documentation"},{"location":"Rover/hardware/","text":"This document describes the hardware, both the mechanical parts and the electronics.. The main structure Link The figure below gives an overview of the main components. The mechanical components Link The frame Link The wheels Link The boxes Link The CNC Link We use currently use the X-Carve. Please follow X-Carve's documentation at . The Z-axis Link The cover Link The electronics Link The basic architecture of the control modules Link NOTE : The current rovers don't implements the schema above, yet: The CNC has no encoders. The rover in Valldaur doesn't have a control panel. The control panel Link NOTE : The control panel is still being developed at the time of writing. The control panel is used to start and stop the rover and to display status information on the character display. Component Specifications Example Controller Arduino Uno or equivalent Proto shield The shield allows you to solder the wires securely Adafruit Sparkfun Amazon Relay (2x) TODO Sparkfun Push button with LEDS (2x) One green and one red Adafruit LCD Character Display Comptable with XXX Farnell The power circuit Link NOTE : This is the new power circuit that will be used with the control panel. It's currently not implemented in either rover. There are three separate power circuits: Always-on circuit : This circuits powers the control panel. Logic circuit : This circuits powers the embedded PC and other control circuits. Power circuit : This circuit drives all the motors. This is the circuit that is cut when the security switch (the big red button) is pressed. The control panel actuates two relays (Relay 1 2) according to the two start-up phases (the PC and the logic circuits start up first, then the motors are powered up). The third relay is designed to handle strong currents. It has a protection against sparks and back-currents. Most of the logic runs on 5V. (TODO: Add a Meanwell power converter. Q: One converter for the the control panel + one of the logic circuit? Or one single converter?) The figure does not show the power line for the weeding hoe. The hoe is turned on/off using a fourth relay that is connected to the gShield board of the CNC. It using the CNC's spindle on/off functionality. You can find more information on this in the section on the CNC below. Component Specifications Example Relay Non-Latching, protection against sparks and back-current (TODO: be more precise) RS Online Security switch Farnell: button and housing The navigation module Link The navigation uses a differential wheel drive, with two motorized wheels in the back and two swivel caster in the front. This makes the control fairly straight-forward and the components are easy to source. The navigation module can also receive input from a remote control to steer the rover. The main components are shown below: Components Link Component Specifications Example Motors Brushed DC motors , 24 V, minimum 200 W We are using wheel chair motors for now. We bought a set at Superdroid Robots . Encoders Incremental encoders US Digital E2 (Available from Superdroid Robotics ). Controller Arduino Uno or equivalent Proto shield The shield allows you to solder the wires securely Adafruit Sparkfun Amazon Motor driver Preferably one board that can drive two motors. Two drivers, one for each motor, is possible, too. Power input: 24V, Maximum output current: 15 A per motor, Control signals: two PWM signals (similar to RC input) for the left and right motor. The driver implements a standard H-bridge to control to power supplied to the motors (both forward and backward rotation). Sabertooth 2x60A Sabertooth 2x32A RoboClaw 2x60A RC controller and receiver A standard RC receiver that outputs a PWM signal. Powered by 5V. We've succesfully used the remote controllers for Spektrum , this one for example or similar Wheels You will need those, too. We are using the wheel provided by Superdroid Robotics for now Wiring diagram Link The tool positioning Link A CNC is adapted for use in the rover. We replaced the spindle that is normally used to carve wooden pieces, with a rotating weeding hoe. We are using to larger, 1000 mm sized version of the X-Carve . The newer X-Carve uses a custom design board for the control. However, we prefer using the older solution that combines an Arduino Uno with a gShield because it is smaller and more generic. For the time being, we use the grbl language to send commands from the embedded PC to the CNC controller. Therefore, any solution that accepts grbl commands should be drop-in solution for the Uno+gShield combo. Component Specifications Example CNC Minimum work area: 0.7 m x 0.7m X-Carve Optional: Controller board Must run grbl interpreter Arduino Uno Optional: Stepper drivers (3 steppers) The driver must use the STEP/DIR control signals gShield [Arduino CNC Shield] eBay and RepRap You can still have a look at XCarve's older documentation on how to wire the controller boards: http://x-carve-instructions.inventables.com/xcarve2015/step10/ http://x-carve-instructions.inventables.com/xcarve2015/step14/ Notable, the following two diagrams are of interest: The yellow wire marked \"spinle\" in the image above is used to turn the weeding hoe on or off, as shown in the figure below (see also the figure in the section on the power circuit).","title":"Hardware Documentation"},{"location":"Rover/hardware/#the-main-structure","text":"The figure below gives an overview of the main components.","title":"The main structure"},{"location":"Rover/hardware/#the-mechanical-components","text":"","title":"The mechanical components"},{"location":"Rover/hardware/#the-frame","text":"","title":"The frame"},{"location":"Rover/hardware/#the-wheels","text":"","title":"The wheels"},{"location":"Rover/hardware/#the-boxes","text":"","title":"The boxes"},{"location":"Rover/hardware/#the-cnc","text":"We use currently use the X-Carve. Please follow X-Carve's documentation at .","title":"The CNC"},{"location":"Rover/hardware/#the-z-axis","text":"","title":"The Z-axis"},{"location":"Rover/hardware/#the-cover","text":"","title":"The cover"},{"location":"Rover/hardware/#the-electronics","text":"","title":"The electronics"},{"location":"Rover/hardware/#the-basic-architecture-of-the-control-modules","text":"NOTE : The current rovers don't implements the schema above, yet: The CNC has no encoders. The rover in Valldaur doesn't have a control panel.","title":"The basic architecture of the control modules"},{"location":"Rover/hardware/#the-control-panel","text":"NOTE : The control panel is still being developed at the time of writing. The control panel is used to start and stop the rover and to display status information on the character display. Component Specifications Example Controller Arduino Uno or equivalent Proto shield The shield allows you to solder the wires securely Adafruit Sparkfun Amazon Relay (2x) TODO Sparkfun Push button with LEDS (2x) One green and one red Adafruit LCD Character Display Comptable with XXX Farnell","title":"The control panel"},{"location":"Rover/hardware/#the-power-circuit","text":"NOTE : This is the new power circuit that will be used with the control panel. It's currently not implemented in either rover. There are three separate power circuits: Always-on circuit : This circuits powers the control panel. Logic circuit : This circuits powers the embedded PC and other control circuits. Power circuit : This circuit drives all the motors. This is the circuit that is cut when the security switch (the big red button) is pressed. The control panel actuates two relays (Relay 1 2) according to the two start-up phases (the PC and the logic circuits start up first, then the motors are powered up). The third relay is designed to handle strong currents. It has a protection against sparks and back-currents. Most of the logic runs on 5V. (TODO: Add a Meanwell power converter. Q: One converter for the the control panel + one of the logic circuit? Or one single converter?) The figure does not show the power line for the weeding hoe. The hoe is turned on/off using a fourth relay that is connected to the gShield board of the CNC. It using the CNC's spindle on/off functionality. You can find more information on this in the section on the CNC below. Component Specifications Example Relay Non-Latching, protection against sparks and back-current (TODO: be more precise) RS Online Security switch Farnell: button and housing","title":"The power circuit"},{"location":"Rover/hardware/#the-navigation-module","text":"The navigation uses a differential wheel drive, with two motorized wheels in the back and two swivel caster in the front. This makes the control fairly straight-forward and the components are easy to source. The navigation module can also receive input from a remote control to steer the rover. The main components are shown below:","title":"The navigation module"},{"location":"Rover/hardware/#components","text":"Component Specifications Example Motors Brushed DC motors , 24 V, minimum 200 W We are using wheel chair motors for now. We bought a set at Superdroid Robots . Encoders Incremental encoders US Digital E2 (Available from Superdroid Robotics ). Controller Arduino Uno or equivalent Proto shield The shield allows you to solder the wires securely Adafruit Sparkfun Amazon Motor driver Preferably one board that can drive two motors. Two drivers, one for each motor, is possible, too. Power input: 24V, Maximum output current: 15 A per motor, Control signals: two PWM signals (similar to RC input) for the left and right motor. The driver implements a standard H-bridge to control to power supplied to the motors (both forward and backward rotation). Sabertooth 2x60A Sabertooth 2x32A RoboClaw 2x60A RC controller and receiver A standard RC receiver that outputs a PWM signal. Powered by 5V. We've succesfully used the remote controllers for Spektrum , this one for example or similar Wheels You will need those, too. We are using the wheel provided by Superdroid Robotics for now","title":"Components"},{"location":"Rover/hardware/#wiring-diagram","text":"","title":"Wiring diagram"},{"location":"Rover/hardware/#the-tool-positioning","text":"A CNC is adapted for use in the rover. We replaced the spindle that is normally used to carve wooden pieces, with a rotating weeding hoe. We are using to larger, 1000 mm sized version of the X-Carve . The newer X-Carve uses a custom design board for the control. However, we prefer using the older solution that combines an Arduino Uno with a gShield because it is smaller and more generic. For the time being, we use the grbl language to send commands from the embedded PC to the CNC controller. Therefore, any solution that accepts grbl commands should be drop-in solution for the Uno+gShield combo. Component Specifications Example CNC Minimum work area: 0.7 m x 0.7m X-Carve Optional: Controller board Must run grbl interpreter Arduino Uno Optional: Stepper drivers (3 steppers) The driver must use the STEP/DIR control signals gShield [Arduino CNC Shield] eBay and RepRap You can still have a look at XCarve's older documentation on how to wire the controller boards: http://x-carve-instructions.inventables.com/xcarve2015/step10/ http://x-carve-instructions.inventables.com/xcarve2015/step14/ Notable, the following two diagrams are of interest: The yellow wire marked \"spinle\" in the image above is used to turn the weeding hoe on or off, as shown in the figure below (see also the figure in the section on the power circuit).","title":"The tool positioning"},{"location":"Rover/manual/","text":"TODO: Overview Preparing the beds Main components of the rover Charging the battery Turning the rover on/off The web interface Configuration Calibration Starting a program Modifying a program Adding a program Assistance Troubleshooting","title":"User Manual"},{"location":"Rover/software/","text":"Overview Link This document describes how to run and compile the software for the ROMI Rover. If you are a developer looking for details on the source code then have a look at the separate Developer Documentation . Prerequisites Link The software of the rover runs on Linux. It is not tied to a specific Linux distribution but we have tested it mostly on recent versions of Debian (includin Raspian) and Ubuntu. The software is mostly writen in C and depends on the following libraries: libr : Common code for the rcom and the libromi libraries. It provides some OS abstraction (for example for threads, memory allocation, file system, networking), some core functionality (logging, time), and some base classes (variable-size memory buffers, json parser, lists, serial connections). Code rcom : An inter-process communication framework. It provides real-time communication using UDP messages and high-level communication based on web protocols (HTTP, Websockets). It also includes several utilities to develop and manage rcom applications. Code libromi : Base classes for the romi rover: fsdb (database with filesystem back-end), image loading and manipulations, \u2026) Code romi-brush-motor-controller : The motor controller. Code romi-rover : All of the apps for the Romi rover. Code By default, the rover uses a USB camera. It is possible to use the Intel Realsense camera on the Picamera instead. In that case, you will have to install additional libraries (see XXX). Installing a Raspberry Pi from scratch Link We use the Lite version of Raspbian. You can download it at https://www.raspberrypi.org/downloads/raspbian/ . There are several ways to prepare the disk image for the RPi. Check the page at https://www.raspberrypi.org/documentation/installation/installing-images/ (there\u2019s lots of information available on this topic online) and follow the instructions that suit you best. Once you have the SD card, connect RPi to screen, keyboard and network (ethernet), power up the board and log in (user pi , password raspberry ). The first thing you want to do is change some of the default settings using the raspi-config tool. In the console type: $ sudo raspi-config The list of settings that you may want to look at includes: 1 Change User Password 2 Network Options Hostname WiFi 4 Localisation Options Change locales Change keyboard layout 5 Interfacing Options Enable Camera Enable SSH 8 Update Next, create the user \u2018romi\u2019: $ sudo adduser romi $ sudo adduser romi dialout $ sudo adduser romi video $ sudo adduser romi sudo After that, quit the current session and login again as user \u2018romi\u2019. The nano text editor is installed by default but if you prefer anoher editor, now is a good time to install it: $ sudo apt install emacs-nox ( ... or any editor you like : ) Install the developer tools: $ sudo apt install build-essential cmake git Install the software dependencies: $ sudo apt install libpng-dev libjpeg9-dev That's it. You should be ready. Quick install #!/bin/bash # Install the dependencies sudo apt install build-essential cmake git libpng-dev libjpeg9-dev # Download, compile and install the libraries apps for id in libr rcom libromi romi-rover ; do echo ---------------------------------------------- echo Compiling $id # Download or update the github repository if [ -d $id ] ; then cd $id git pull else git clone https://github.com/romi/ $id .git cd $id fi # Standard cmake build sequence mkdir -p build cd build cmake .. make sudo make install sudo ldconfig # Get ready for the next component cd ../.. done Installing the romi-rover apps Link You should first install the libr , rcom , and libromi libraries. Check out their the Github pages for the installation instruction and the API documentation. You should also flash the motor controller to the Arduino (instructions are available on Github ) too. Once that is done, the installation of the romi-rover apps is straight-forward. First, check out the code: $ git clone https://github.com/romi/romi-rover.git Then proceed to the compilation and installation: $ cd romi-rover $ mkdir build $ cd build $ cmake .. $ make $ sudo make install Compiling the picamera app Link Although not currently used by the ROMI Rover, we have an Rcom app to access the Picamera. To get it working, you will first have to install the raspicam library: $ git clone https://github.com/cedricve/raspicam.git $ cd raspicam/ $ mkdir build $ cd build/ $ cmake .. $ make $ sudo make install $ sudo ldconfig Once raspicam is installed, you must re-run cmake to enable the compilation of the picamera app: $ cd romi-rover/build/ $ rm CMakeCache.txt $ cmake .. -DWITH_PICAMERA = ON $ make $ sudo make install Compiling the realsense app Link The fonctionality of the Realsense camera app is not complete. You can use it to obtain RGB images and depth images (as BW PNG images). You will first have to install librealsense2 . When librealsense is installed, re-run cmake to enable the compilation of the realsense app: $ cd romi-rover/build/ $ rm CMakeCache.txt $ cmake .. -DWITH_REALSENSE = ON $ make $ sudo make install Configuration Link Configuring the romi-rover apps Link In the directory /home/romi, create the following directories and copy the default configuration and script files: $ cd /home/romi $ mkdir sessions $ mkdir config $ cp romi-rover /config/config-romi-rover.json config/ $ mkdir scripts $ cp romi-rover /script/config-default.json scripts/ html : romi-rover /interface/html , Starting the apps on boot Link Currently we are still using the old rc.local mechanism. The file /etc/rc.local is no longer included in more recent Ubuntu versions. If ls / etc / rc . local returns an error, you will have to create the file as follows: $ sudo nano /etc/rc.local Copy the following contents: #!/bin/sh -e # # rc.local # # This script is executed at the end of each multiuser runlevel. # Make sure that the script will exit 0 on success or any other # value on error. # # In order to enable or disable this script just change the execution # bits. # # By default this script does nothing. exit 0 Finally, make the script executable. $ sudo chmod +x /etc/rc.local To enable the apps on start-up, add the following line in /etc/rc.local, above the exit 0 line: /usr/local/bin/rclaunch /home/romi/config/config-romi-rover.json Configuring the image uploads Link Annex: the apps and their options Link fake_camera : { image : data/camera.jpg } ,","title":"Software Installation"},{"location":"Rover/software/#overview","text":"This document describes how to run and compile the software for the ROMI Rover. If you are a developer looking for details on the source code then have a look at the separate Developer Documentation .","title":"Overview"},{"location":"Rover/software/#prerequisites","text":"The software of the rover runs on Linux. It is not tied to a specific Linux distribution but we have tested it mostly on recent versions of Debian (includin Raspian) and Ubuntu. The software is mostly writen in C and depends on the following libraries: libr : Common code for the rcom and the libromi libraries. It provides some OS abstraction (for example for threads, memory allocation, file system, networking), some core functionality (logging, time), and some base classes (variable-size memory buffers, json parser, lists, serial connections). Code rcom : An inter-process communication framework. It provides real-time communication using UDP messages and high-level communication based on web protocols (HTTP, Websockets). It also includes several utilities to develop and manage rcom applications. Code libromi : Base classes for the romi rover: fsdb (database with filesystem back-end), image loading and manipulations, \u2026) Code romi-brush-motor-controller : The motor controller. Code romi-rover : All of the apps for the Romi rover. Code By default, the rover uses a USB camera. It is possible to use the Intel Realsense camera on the Picamera instead. In that case, you will have to install additional libraries (see XXX).","title":"Prerequisites"},{"location":"Rover/software/#installing-a-raspberry-pi-from-scratch","text":"We use the Lite version of Raspbian. You can download it at https://www.raspberrypi.org/downloads/raspbian/ . There are several ways to prepare the disk image for the RPi. Check the page at https://www.raspberrypi.org/documentation/installation/installing-images/ (there\u2019s lots of information available on this topic online) and follow the instructions that suit you best. Once you have the SD card, connect RPi to screen, keyboard and network (ethernet), power up the board and log in (user pi , password raspberry ). The first thing you want to do is change some of the default settings using the raspi-config tool. In the console type: $ sudo raspi-config The list of settings that you may want to look at includes: 1 Change User Password 2 Network Options Hostname WiFi 4 Localisation Options Change locales Change keyboard layout 5 Interfacing Options Enable Camera Enable SSH 8 Update Next, create the user \u2018romi\u2019: $ sudo adduser romi $ sudo adduser romi dialout $ sudo adduser romi video $ sudo adduser romi sudo After that, quit the current session and login again as user \u2018romi\u2019. The nano text editor is installed by default but if you prefer anoher editor, now is a good time to install it: $ sudo apt install emacs-nox ( ... or any editor you like : ) Install the developer tools: $ sudo apt install build-essential cmake git Install the software dependencies: $ sudo apt install libpng-dev libjpeg9-dev That's it. You should be ready. Quick install #!/bin/bash # Install the dependencies sudo apt install build-essential cmake git libpng-dev libjpeg9-dev # Download, compile and install the libraries apps for id in libr rcom libromi romi-rover ; do echo ---------------------------------------------- echo Compiling $id # Download or update the github repository if [ -d $id ] ; then cd $id git pull else git clone https://github.com/romi/ $id .git cd $id fi # Standard cmake build sequence mkdir -p build cd build cmake .. make sudo make install sudo ldconfig # Get ready for the next component cd ../.. done","title":"Installing a Raspberry Pi from scratch"},{"location":"Rover/software/#installing-the-romi-rover-apps","text":"You should first install the libr , rcom , and libromi libraries. Check out their the Github pages for the installation instruction and the API documentation. You should also flash the motor controller to the Arduino (instructions are available on Github ) too. Once that is done, the installation of the romi-rover apps is straight-forward. First, check out the code: $ git clone https://github.com/romi/romi-rover.git Then proceed to the compilation and installation: $ cd romi-rover $ mkdir build $ cd build $ cmake .. $ make $ sudo make install","title":"Installing the romi-rover apps"},{"location":"Rover/software/#compiling-the-picamera-app","text":"Although not currently used by the ROMI Rover, we have an Rcom app to access the Picamera. To get it working, you will first have to install the raspicam library: $ git clone https://github.com/cedricve/raspicam.git $ cd raspicam/ $ mkdir build $ cd build/ $ cmake .. $ make $ sudo make install $ sudo ldconfig Once raspicam is installed, you must re-run cmake to enable the compilation of the picamera app: $ cd romi-rover/build/ $ rm CMakeCache.txt $ cmake .. -DWITH_PICAMERA = ON $ make $ sudo make install","title":"Compiling the picamera app"},{"location":"Rover/software/#compiling-the-realsense-app","text":"The fonctionality of the Realsense camera app is not complete. You can use it to obtain RGB images and depth images (as BW PNG images). You will first have to install librealsense2 . When librealsense is installed, re-run cmake to enable the compilation of the realsense app: $ cd romi-rover/build/ $ rm CMakeCache.txt $ cmake .. -DWITH_REALSENSE = ON $ make $ sudo make install","title":"Compiling the realsense app"},{"location":"Rover/software/#configuration","text":"","title":"Configuration"},{"location":"Rover/software/#configuring-the-romi-rover-apps","text":"In the directory /home/romi, create the following directories and copy the default configuration and script files: $ cd /home/romi $ mkdir sessions $ mkdir config $ cp romi-rover /config/config-romi-rover.json config/ $ mkdir scripts $ cp romi-rover /script/config-default.json scripts/ html : romi-rover /interface/html ,","title":"Configuring the romi-rover apps"},{"location":"Rover/software/#starting-the-apps-on-boot","text":"Currently we are still using the old rc.local mechanism. The file /etc/rc.local is no longer included in more recent Ubuntu versions. If ls / etc / rc . local returns an error, you will have to create the file as follows: $ sudo nano /etc/rc.local Copy the following contents: #!/bin/sh -e # # rc.local # # This script is executed at the end of each multiuser runlevel. # Make sure that the script will exit 0 on success or any other # value on error. # # In order to enable or disable this script just change the execution # bits. # # By default this script does nothing. exit 0 Finally, make the script executable. $ sudo chmod +x /etc/rc.local To enable the apps on start-up, add the following line in /etc/rc.local, above the exit 0 line: /usr/local/bin/rclaunch /home/romi/config/config-romi-rover.json","title":"Starting the apps on boot"},{"location":"Rover/software/#configuring-the-image-uploads","text":"","title":"Configuring the image uploads"},{"location":"Rover/software/#annex-the-apps-and-their-options","text":"fake_camera : { image : data/camera.jpg } ,","title":"Annex: the apps and their options"}]}